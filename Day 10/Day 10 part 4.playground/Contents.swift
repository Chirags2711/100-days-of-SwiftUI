struct Player {
    let name: String
    let number: Int

    init(name: String, number: Int) { //Also generated by default. Memberwise init. If any of your properties have default values, then they’ll be incorporated into the initializer as default parameter values.
        self.name = name
        self.number = number
    }
}

//initializers never explicitly have a return type – they always return the type of data they belong to.

//The golden rule: all properties must have a value by the time the initializer ends, otherwise Swift would refuse to build our code.
//Important: Although you can call other methods of your struct inside your initializer, you can’t do so before assigning values to all your properties – Swift needs to be sure everything is safe before doing anything else.
//Can use external parameter names and default values

struct Employee2 {
    var name: String
    var yearsActive = 0
}

let roslin = Employee2(name: "Laura Roslin")
let adama = Employee2(name: "William Adama", yearsActive: 45)


//As soon as you add a custom initializer for your struct, the default memberwise initializer goes away.
//If you want it to stay, move your custom initializer to an extension, like this:
struct Employee {
    var name: String
    var yearsActive = 0
}

extension Employee {
    init() {
        self.name = "Anonymous"
        print("Creating an anonymous employee…")
    }
}

// creating a named employee now works, which won't be the case if we declared custom init in the struct itself, without using extension
let roslin2 = Employee(name: "Laura Roslin")

// as does creating an anonymous employee
let anon = Employee()



//Outside of initializers, the main reason for using self is because we’re in a closure and Swift requires it so we’re clear we understand what’s happening. This is only needed when accessing self from inside a closure that belongs to a class, and Swift will refuse to build your code unless you add it.


